[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "metaSurvey",
    "section": "",
    "text": "Descripción del proyecto\nmetaSurvey además de formar parte de mi trabajo final de grado en Estadística tiene varias motivaciones en el medio, entre ellas el objetivo personal de poder contribuir en el desarrollo de paquetes de la comunidad R, ilusión que tengo desde que cursé en plena pandemia Nuevas Tecnologías para el Análisis de Datos con Natalia, mi actual tutora y curso donde tuve la oportunidad de ser ayudante en su nueva versión Ciencia de datos con R torturando y trasmitiendo a los alumnos sobre el uso de R en diversos campos cercanos a la estadística. La creación de un paquete en R no fue ni es una tarea sencilla, si bien existen diferentes herramientas y paquetes para hacer la vida de los desarrolladores mas facil, el gran problema es poder encontrar una idea, motivación y tiempo para poder realizarlo. El sueño de tener un paquete era facil de soñar pero dificil de encontrar una idea original y aún mas disponer del tiempo para hacerlo.\nEn noviembre de 2021 en mi trabajo como Analista de Datos en COGNUS se me ofreció formar parte del desarrollo de PRISMA un portal de la Agencia Nacional de Innovación e Investigación (ANII) donde mi tarea principal fue trabajar con datos provenientes de encuestas por muestreo para obtener diferentes indicadores publicados a lo largo del portal.\nEl portal tiene como objetivo ser un sitio que reuna información e indicadores de interés para investigadores e emprendedores del país, si bien una gran parte de la información es generada por la Agencia es importante tener un contexto economíco del país como puede ser indicadores de mercado de trabajo e ingresos de los hogares recurriendo a la fuente principal de información en este rubro, la Encuesta Continua de Hogares (ECH) del Instituto Nacional de Estadística de Uruguay (INE). Además de contar con esta información es relevante medir el impacto de ciertas politicas en la innovación en nuestro país y es por esto que se construyen indicadores provenientes de la Encuesta de Actividades de Innovación (EAI)\nde la cual soy muy admirador llegando a que admirar casí de la misma forma que lo hago con artistas pop a los principales desarrolladores, como pueden ser Hadley Wickham,"
  },
  {
    "objectID": "chapters/chapter1.html#footnotes",
    "href": "chapters/chapter1.html#footnotes",
    "title": "1  Introducción",
    "section": "",
    "text": "Aquí puede verse el código fuente de la función get_flow del paquete tidycensus donde se puede en la linea 151 la recodificación de variables se hace con una tabla mig_recodes y al explorar el contenido puede verse como se recodifican las variables además de que la función también tiene código para manejar la forma de presentación de los datos, manipulación de datos geográficos y la estructura del objeto a devolver.↩︎"
  },
  {
    "objectID": "chapters/chapter2.html#desarrollo-de-paquetes-en-r",
    "href": "chapters/chapter2.html#desarrollo-de-paquetes-en-r",
    "title": "2  Marco conceptual",
    "section": "2.1 Desarrollo de paquetes en R",
    "text": "2.1 Desarrollo de paquetes en R\nR al ser un lenguaje de código abierto y además cuenta con una gran comunidad de usuarios, en diferentes áreas de investigación, ha permitido que se desarrollen una gran cantidad de paquetes que permiten realizar diferentes tareas de análisis de datos, visualización, modelado, entre otros. En este sentido, el desarrollo de paquetes en R es una tarea que se ha vuelto muy común entre los usuarios de R, ya que permite compartir código, documentación y datos de manera sencilla.\nPara casí cualquier disciplina científica o en la industria se puede encontrar una comunidad de usuarios que desarollan paquetes en R, en este sentido, el desarrollo de paquetes en R es una tarea que se ha vuelto muy común entre los usuarios de R y es muy sencillo de realizar. A continuación, se presentan los conceptos básicos para el desarrollo de paquetes en R.\n\n2.1.1 ¿Por qué desarrollar un paquete en R?\nDesarrollar un paquete en R tiene varias ventajas, entre las cuales se pueden mencionar las siguientes:\n\nReutilización de código: Es importante tener en cuenta que existe una comunidad que hace cosas similares a las que uno hace, por lo que es posible que alguien ya haya escrito una función que uno necesita. Por lo tanto, siempre es buena buscar si existe algun paquete que ya tenga las funcionalidades que se requieren.\nCompartir código: La comunidad de R es muy activa y siempre está dispuesta a compartir código, por esta razón es que se mantienen en constante desarrollo de paquetes.\nColaboración: El trabajo colaborativo es esencial en el desarrollo de paquetes en R, ya que permite que diferentes personas puedan aportar con nuevas funcionalidades, correcciones de errores, entre otros.\n\n\n\n2.1.2 Elementos básicos de un paquete en R\nPara que nuestro conjunto de funciones, datos y documentación sea considerado un paquete en R, es necesario que cumpla con ciertos requisitos mínimos. A continuación, se presentan los componentes mínimos que debe tener un paquete en R para ser publicado en CRAN.\n\nDirectorio: Un paquete en R debe estar contenido en un directorio que contenga al menos los siguientes archivos y directorios:\n\nR/: Directorio que contiene los archivos con las funciones que se desean incluir en el paquete.\nman/: Directorio que contiene los archivos con la documentación de las funciones que se encuentran en el directorio R/. En general se utiliza Roxygen2 (Wickham et al., 2024) para generar la documentación de las funciones.\nDESCRIPTION: Archivo que contiene la descripción del paquete, incluyendo el nombre, versión, descripción, autor, entre otros.\nNAMESPACE: Archivo que contiene la información sobre las funciones que se exportan y las dependencias del paquete.\nLICENSE: Archivo que contiene la licencia bajo la cual se distribuye el paquete.\nREADME.md: Archivo que contiene información general sobre el paquete.\n\nDocumentación: La documentación de las funciones es un componente esencial de un paquete en R, ya que permite que los usuarios puedan entender el funcionamiento de las funciones que se encuentran en el paquete. La documentación de las funciones se realiza utilizando el sistema de documentación de R, que se basa en el uso de comentarios en el código fuente de las funciones.\nPruebas: Es importante que el paquete tenga pruebas que permitan verificar que las funciones se comportan de la manera esperada. Las pruebas se realizan utilizando el paquete testthat (Wickham, 2011) que permite realizar pruebas unitarias.\nControl de versiones: Es importante que el paquete tenga un sistema de control de versiones que permita llevar un registro de los cambios que se realizan en el paquete. El sistema de control de versiones más utilizado en la comunidad de R es git.\nLicencia: Es importante que el paquete tenga una licencia que permita a los usuarios utilizar, modificar y distribuir el paquete. La licencia más utilizada en la comunidad de R es la licencia MIT.\n\nEl proceso de subir un paquete a CRAN es un proceso que puede ser tedioso, ya que se deben cumplir con ciertos requisitos que son revisados por los mantenedores de CRAN, no es trivial y puede tomar tiempo, sin embargo, es un proceso que vale la pena ya que permite que el paquete sea utilizado por una gran cantidad de usuarios.\nEl proceso de chequeo fue automatizado con github actions, por lo que cada vez que se realiza un cambio en el repositorio, se ejecutan los chequeos de CRAN y se notifica si el paquete cumple con los requisitos para ser publicado en caso de que no cumpla con los requisitos se notifica el error y no puede ser incluido en la rama principal del repositorio hasta que se corrija el error.\nTodo el proceso y código fuente del paquete se encuentra disponible en el repositorio de github del paquete. En el caso que este interesado en colaborar con el desarrollo del paquete puede consultar la guía de contribución"
  },
  {
    "objectID": "chapters/chapter2.html#paradigmas-de-programación-en-r",
    "href": "chapters/chapter2.html#paradigmas-de-programación-en-r",
    "title": "2  Marco conceptual",
    "section": "2.2 Paradigmas de programación en R",
    "text": "2.2 Paradigmas de programación en R\nR es un lenguaje de programación que permite realizar programación funcional y orientada a objetos, lo que permite que los usuarios puedan utilizar diferentes paradigmas de programación para resolver problemas. A continuación, se presentan los conceptos básicos de la programación funcional y orientada a objetos en R.\n\n2.2.1 Programación funcional\nLa programación funcional es un paradigma de programación que se basa en el uso de funciones para resolver problemas. En R, las funciones son objetos de primera clase, lo que significa que se pueden utilizar como argumentos de otras funciones, se pueden asignar a variables, entre otros (Wickham, 2019, pp. 204–281). A continuación, se presentan los conceptos básicos de la programación funcional en R.\n\nFunciones de orden superior: En R, las funciones de orden superior son funciones que toman como argumento una o más funciones y/o retornan una función. Un ejemplo de una función de orden superior en R es la función lapply que toma como argumento una lista y una función y retorna una lista con los resultados de aplicar la función a cada elemento de la lista.\nFunciones anónimas: En R, las funciones anónimas son funciones que no tienen nombre y se crean utilizando la función function. Un ejemplo de una función anónima en R es la función function(x) x^2 que toma como argumento x y retorna x^2.\nFunciones puras: En R, las funciones puras son funciones que no tienen efectos secundarios y retornan el mismo resultado para los mismos argumentos. Un ejemplo de una función pura en R es la función sqrt que toma como argumento un número y retorna la raíz cuadrada de ese número.\n\nEste paradigma de programación es muy útil para realizar análisis de datos, ya que permite que los usuarios puedan utilizar funciones para realizar operaciones sobre los datos de manera sencilla y eficiente, dentro de metaSurvey no existe una presencia fuerte de programación funcional, sin embargo, se utilizan algunas funciones de orden superior para realizar operaciones sobre los datos.\n\n\n2.2.2 Programación orientada a objetos\nLa programación orientada a objetos es un paradigma de programación que se basa en el uso de objetos para resolver problemas. En R, los objetos son instancias de clases que tienen atributos y métodos (Mailund, 2017; Wickham, 2019, pp. 285–370). A continuación, se presentan los conceptos básicos de la programación orientada a objetos en R.\n\nClases y objetos: En R, las clases son plantillas que definen la estructura y el comportamiento de los objetos y los objetos son instancias de clases. En R, las clases se definen utilizando la función setClass y los objetos se crean utilizando la función new.\nAtributos y métodos: En R, los atributos son variables que almacenan información sobre el estado de un objeto y los métodos son funciones que permiten modificar el estado de un objeto. En R, los atributos se definen utilizando la función setClass y los métodos se definen utilizando la función setMethod.\n\nDentro de metaSurvey se utiliza la programación orientada a objetos para definir las clases de los objetos que se utilizan para representar los datos de las encuestas mediante una creación de una clase especifica llamada Survey que permite además de almacenar los datos de la encuesta añadir atributos y métodos que permiten realizar operaciones sobre los datos de manera sencilla y eficiente.\nDe forma similar se modelan las clases Step, Recipe y Workflow elementos cruciales en el ecosistema de metaSurvey donde se definen los pasos de preprocesamiento, recetas de preprocesamiento y flujos de trabajo respectivamente. En este caso particular se utiliza el paquete R6 (Chang, 2022) que permite definir clases de manera sencilla y eficiente además de permitir la herencia de clases y la definición de métodos y atributos de manera sencilla.\n\n\n2.2.3 Meta-programación\nLa meta-programación es un paradigma de programación que se basa en el uso de código para manipular código (Thomas Mailund, 2017; Wickham, 2019, pp. 373–500) . En R, la meta-programación se realiza utilizando el sistema de metaprogramación de R que se basa en el uso de expresiones, llamadas y funciones. A continuación, se presentan los conceptos básicos de la meta-programación en R.\n\nExpresiones: En R, las expresiones son objetos que representan código y se crean utilizando la función quote. Un ejemplo de una expresión en R es la expresión quote(x + y) que representa el código x + y.\nLlamadas: En R, las llamadas son objetos que representan la aplicación de una función a sus argumentos y se crean utilizando la función call. Un ejemplo de una llamada en R es la llamada call(\"sum\", 1, 2, 3) que representa la aplicación de la función sum a los argumentos 1, 2 y 3.\nFunciones: En R, las funciones son objetos que representan código y se crean utilizando la función function. Un ejemplo de una función en R es la función function(x, y) x + y que representa el código x + y."
  },
  {
    "objectID": "chapters/chapter2.html#inferencia-en-muestreo-de-poblaciones-finitas",
    "href": "chapters/chapter2.html#inferencia-en-muestreo-de-poblaciones-finitas",
    "title": "2  Marco conceptual",
    "section": "2.3 Inferencia en muestreo de poblaciones finitas",
    "text": "2.3 Inferencia en muestreo de poblaciones finitas\nEl objetivo de esta sección es brindar un contexto básico sobre encuestas por muestreo, para luego presentar diferentes métodos de estimación de parámetros poblacionales como la estimación de totales, medias, proporciones y sus respectivos errores estándar.\nEl elemento crucial en la Inferencia en muestreo de poblaciones finitas es que se asume que la población es finita y la aleatoriedad proviene de la selección de la muestra, por lo que es necesario considerar la probabilidad de selección de cada muestra posible. Es común escuchar el término diseño en el contexto de encuestas por muestreo, el diseño de muestreo es el mecanismo que se utiliza para seleccionar la muestra, existen diferentes tipos de diseños que se utilizan en la práctica, sin embargo nos enfocaremos en el proceso de construcción de ponderadores los cuales son fundamentales para realizar inferencia.\nSupongamos que estamos interesados en estimar el total de una variable de interés \\(y\\) en una población finita, es decir, el total poblacional \\(T_y = \\sum_{i=1}^{N} y_i\\), donde \\(y_i\\) es el valor de la variable de interés para el individuo \\(i\\) de la población y \\(N\\) es el tamaño de la población. Si se selecciona una muestra de \\(n\\) elementos de la población, es posible estimar el total poblacional utilizando la siguiente fórmula:\n\\[\n\\hat{T}_y = \\sum_{i=1}^{n} y_i\n\\]\nDonde \\(\\hat{T}_y\\) es el estimador del total poblacional, \\(y_i\\) es el valor de la variable de interés para el individuo \\(i\\) de la muestra y \\(n\\) es el tamaño de la muestra. Es importante tener en cuenta que el estimador del total poblacional depende del mecanismo de muestreo que se utilice, para esto debemos de mencionar la siguiente variable aleatoria:\nAsumiendo un diseño concreto es decir, fijada \\(p(s)\\) podemos definir la variable (aleatoria) de pertenencia a la muestra \\(s\\) como:\n\\[\nI_{k} = \\begin{cases} 1 & \\text{si el individuo } k \\text{ pertenece a la muestra } s \\\\ 0 & \\text{en otro caso} \\end{cases}\n\\]\nDe esta forma es posible calcular la probabilidad de que el indivudo \\(k\\) sea incluido en la muestra \\(s\\), es decir \\(\\pi_k = E(I_k) = P(I_k = 1)\\) ya que es una variable aleatoria del tipo Bernoulli con probabilidad de éxito \\(\\pi_k\\). Por lo que es estimar calcular total poblacional de la siguiente forma:\n\\[\n\\hat{T}_y = \\sum_{k=1}^{n} y_k = \\sum_{k = 1}^{n}{y_{i} \\times I_{k}} = \\sum_{k = 1}^{N}{}\n\\]\nEste ultimo paso nos permite realizar el\nEs decir, si consideramos una población de \\(N\\) elementos (donde \\(N\\) es finito y puede ser desconocido) y se selecciona una muestra \\(s\\) de \\(n\\) elementos. Cada individuo de la pobación tiene una probabilidad de ser seleccionado en la muestra, dependiendo el mecanismo de muestreo que se utilice. Cada muestra de \\(n\\) elementos tiene una probabilidad de ser seleccionada la que denominaremos función de diseño \\(p(s)\\), por lo que es posible asignar una probabilidad de selección a cada individuo de la población, es decir contar aquellas veces que un individuo fue seleccionado en todas las posibles muestras de \\(n\\) elementos, esto se conoce como probabilidad de inclusión de primer órden.\nExisten diseños sencillos donde es facil obtener la probabilidad de selección de cada individuo de la población, como el muestreo aleatorio simple (SI), muestreo sistemático (SY), muestreo estratificado, muestreo por conglomerados, entre otros. La utilización de uno u otro depende de la variable objetivo o grupo de variables que se desea estimar, aunque en la práctica se utilizan diseños complejos que combinan varios de estos diseños en varias etapas de selección.\nUn ejemplo de este tipo de diseño puede ser la ECH donde se utiliza un muestreo aleatorio en dos etapas, donde en la primera etapa se seleccionan las unidades primarias de muestreo (UPM) correspondientes a conglomerados de manzanas (zonas censales). En la segunda etapa se seleccionan las unidades secundarias de muestreo (USM) correspondientes a viviendas dentro de las manzanas seleccionadas. Luego, se identifican los hogares seleccionados y los individuos que los componen son seleccionados en su totalidad para ser encuestados (Instituto Nacional de Estadı́stica, 2021).\n\n2.3.1 Ejemplo Diseño Simple con remplazo\nConsiderando una población de \\(N\\) elementos existen \\(\\binom{N}{n}\\) maneras de seleccionar una muestra de \\(n\\) elementos, por lo que la probabilidad de seleccionar una muestra \\(s\\) de \\(n\\) elementos es:\n\\[\nP(S = s) = p(s) = 1 / \\binom{N}{n}\n\\]\nUna vez definida la función de diseño, es posible definir las probabilidades de inclusión de primer órden, es decir la probabilidad de que un individuo de la población sea seleccionado en la muestra, esta probabilidad se denota como \\(\\pi_i\\) y se define como para el caso SI.\nSi miramos a un individuo de la población, este puede ser seleccionado en la muestra si y solo si se encuentra en la muestra \\(s\\), por lo que debemos de contar cuantas formas diferentes podemos seleccionar \\(n-1\\) elementos de los \\(N-1\\) restantes, por lo que la probabilidad de inclusión de primer órden es, es decir \\(\\binom{N-1}{n-1}\\), por lo que la probabilidad de inclusión de primer órden es:\n\\[\n\\pi_i = \\frac{\\binom{N-1}{n-1}}{\\binom{N}{n}} = \\frac{n}{N}\n\\]\nUna vez definida la probabilidad de inclusión de primer órden\n\n\n\n\nChang, W. (2022). R6: Encapsulated classes with reference semantics.\n\n\nInstituto Nacional de Estadı́stica. (2021). Metodologı́a de la Encuesta Continua de Hogares Instituto Nacional de Estadı́stica. https://www.ine.gub.uy\n\n\nMailund, T. (2017). Advanced object-oriented programming in r: Statistical programming for data science, analysis and finance. SPRINGER.\n\n\nThomas Mailund. (2017). Metaprogramming in r (1st ed.). Apress. https://www.amazon.com/Metaprogramming-Advanced-Statistical-Programming-Analysis/dp/1484228804\n\n\nWickham, H. (2011). Testthat: Get started with testing. The R Journal, 3, 510. https://journal.r-project.org/archive/2011-1/RJournal_2011-1_Wickham.pdf\n\n\nWickham, H. (2019). Advanced r, second edition. CRC Press.\n\n\nWickham, H., Danenberg, P., Csárdi, G., & Eugster, M. (2024). roxygen2: In-Line Documentation for R. https://roxygen2.r-lib.org/"
  },
  {
    "objectID": "chapters/chapter5.html#ech",
    "href": "chapters/chapter5.html#ech",
    "title": "5  Resultados",
    "section": "5.1 ECH",
    "text": "5.1 ECH\n\nlibrary(magrittr)\n\nmetaSurvey::set_engine(\"data.table\")\n\nEngine: data.table\n\nech_meta = metaSurvey::load_survey(\n  path = metaSurvey::load_survey_example(\"ech_2018.csv\"),\n  svy_type = \"ech\",\n  svy_edition = \"2018\",\n  svy_weight = \"pesoano\"\n)\n\nech_meta_steps = ech_meta %&gt;%\n  metaSurvey::step_recode(\n    \"pea\",\n    pobpcoac %in% 2:5 ~ 1,\n    .default = 0\n  ) %&gt;%\n  metaSurvey::step_recode(\n    \"pet\",\n    pobpcoac != 1 ~ 1,\n    .default = 0\n  ) %&gt;%\n  metaSurvey::step_recode(\n    \"po\",\n    pobpcoac == 2 ~ 1,\n    .default = 0\n  ) %&gt;%\n  metaSurvey::step_recode(\n    \"pd\",\n    pobpcoac %in% 3:5 ~ 1,\n    .default = 0\n  )\n\n\nmetaSurvey::view_graph(ech_meta_steps)"
  },
  {
    "objectID": "chapters/chapter5.html#eaii",
    "href": "chapters/chapter5.html#eaii",
    "title": "5  Resultados",
    "section": "5.2 EAII",
    "text": "5.2 EAII\n\nsvy_example = metaSurvey::load_survey(\n    svy_type = \"eaii\",\n    svy_edition = \"2019-2021\",\n    svy_weight = \"w_trans\",\n    input = metaSurvey::load_survey_example(\"2019-2021.csv\"),\n    dec = \",\"\n)\n\n# as.data.frame(svy_example)\n# as.tibble(svy_example)\n\nnew_svy = svy_example %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"realiza_innovacion\",\n        B1_1_1 == 1 ~ 1,\n        B1_2_1 == 1 ~ 1,\n        B1_3_1 == 1 ~ 1,\n        B1_4_1 == 1 ~ 1,\n        B1_5_1 == 1 ~ 1,\n        B1_6_1 == 1 ~ 1,\n        B1_7_1 == 1 ~ 1,\n        B1_8_1 == 1 ~ 1,\n        B1_9_1 == 1 ~ 1,\n        .default = 0\n    ) %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"sector\",\n        data.table::between(Division, 10, 33) ~ \"Industria\",\n        data.table::between(Division, 34, 99) ~ \"Servicios\",\n        Division == \"C1\" ~ \"Industria\",\n        Division == \"C2\" ~ \"Servicios\",\n        Division == \"E1\" ~ \"Servicios\"\n    ) %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"innovativa\",\n        E1_1_1 == 1 ~ 1,\n        E1_2_1 == 1 ~ 1,\n        .default = 0\n    ) %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"tipo_actividad\",\n        B1_1_1 == 1 ~ \"I + D Interna\",\n        B1_2_1 == 1 ~ \"I + D Externa\",\n        B1_3_1 == 1 ~ \"Bienes de Capital\",\n        B1_4_1 == 1 ~ \"Software\",\n        B1_5_1 == 1 ~ \"Propiedad Intelectual\",\n        B1_6_1 == 1 ~ \"Ingeniería\",\n        B1_7_1 == 1 ~ \"Capacitación\",\n        B1_8_1 == 1 ~ \"Marketing\",\n        B1_9_1 == 1 ~ \"Gestión\",\n        .default = \"Otra\"\n    ) %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"tipo_innovacion\",\n        E1_1_1 == 1 ~ \"Producto\",\n        E1_2_1 == 1 ~ \"Proceso\",\n        .default = \"Otra\"\n    ) %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"cant_traba_tramo\",\n        data.table::between(IG_4_1_3, 0, 4) ~ \"1\",\n        data.table::between(IG_4_1_3, 5, 19) ~ \"2\",\n        data.table::between(IG_4_1_3, 20, 99) ~ \"3\",\n        IG_4_1_3 &gt; 99 ~ \"4\"\n    ) %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"ingreso_vta_pesos\",\n        data.table::between(IG_5_1_1_3, 0, 9942787) ~ \"1\",\n        data.table::between(IG_5_1_1_3, 9942788, 49713934) ~ \"2\", # nolint\n        data.table::between(IG_5_1_1_3, 49713935, 372854507) ~ \"3\", # nolint\n        IG_5_1_1_3 &gt; 372854507 ~ \"4\"\n    ) %&gt;%\n    metaSurvey::step_recode(\n        new_var = \"tamanio\",\n        cant_traba_tramo == \"1\" & ingreso_vta_pesos == \"1\" ~ \"Pequenias\",\n        cant_traba_tramo == \"2\" & ingreso_vta_pesos == \"2\" ~ \"Pequenias\",\n        cant_traba_tramo == \"2\" & ingreso_vta_pesos == \"1\" ~ \"Pequenias\",\n        cant_traba_tramo == \"1\" & ingreso_vta_pesos == \"2\" ~ \"Pequenias\",\n        cant_traba_tramo == \"3\" & ingreso_vta_pesos == \"3\" ~ \"Medianas\",\n        cant_traba_tramo == \"3\" & ingreso_vta_pesos == \"2\" ~ \"Medianas\",\n        cant_traba_tramo == \"3\" & ingreso_vta_pesos == \"1\" ~ \"Medianas\",\n        cant_traba_tramo == \"1\" & ingreso_vta_pesos == \"3\" ~ \"Medianas\",\n        cant_traba_tramo == \"2\" & ingreso_vta_pesos == \"3\" ~ \"Medianas\",\n        cant_traba_tramo == \"4\" & ingreso_vta_pesos == \"4\" ~ \"Grandes\",\n        cant_traba_tramo == \"4\" & ingreso_vta_pesos == \"3\" ~ \"Grandes\",\n        cant_traba_tramo == \"4\" & ingreso_vta_pesos == \"2\" ~ \"Grandes\",\n        cant_traba_tramo == \"4\" & ingreso_vta_pesos == \"1\" ~ \"Grandes\",\n        cant_traba_tramo == \"1\" & ingreso_vta_pesos == \"4\" ~ \"Grandes\",\n        cant_traba_tramo == \"2\" & ingreso_vta_pesos == \"4\" ~ \"Grandes\",\n        cant_traba_tramo == \"3\" & ingreso_vta_pesos == \"4\" ~ \"Grandes\"\n    ) %&gt;%\n    metaSurvey::step_compute(\n        subsector = Division\n    )\n\nmetaSurvey::get_metadata(new_svy)\n\nℹ️  Type: eaii\n💹 Edition: 2019-2021\n🖥️  Engine: data.table\n🧮 Weight: w_trans\n🔍 Steps: \n  - New group: realiza_innovacion\n  - New group: sector\n  - New group: innovativa\n  - New group: tipo_actividad\n  - New group: tipo_innovacion\n  - New group: cant_traba_tramo\n  - New group: ingreso_vta_pesos\n  - New group: tamanio\n  - New variable: subsector\n\n\n\nmetaSurvey::view_graph(new_svy)"
  },
  {
    "objectID": "chapters/chapter5.html#eph",
    "href": "chapters/chapter5.html#eph",
    "title": "5  Resultados",
    "section": "5.3 EPH",
    "text": "5.3 EPH\n\nph2022_3 = metaSurvey::load_survey(\n  path = metaSurvey::load_survey_example(\"eph2022_3.csv\"),\n  svy_type = \"eph\",\n  svy_edition = \"2022_3\",\n  svy_weight = \"PONDERA\"\n) %&gt;% \n  metaSurvey::step_recode(\n    \"pea\",\n    ESTADO %in% 1:2 ~ 1,\n    .default = 0\n  ) %&gt;% \n  metaSurvey::step_recode(\n    \"pet\",\n    ESTADO != 4 ~ 1,\n    .default = 0\n  ) %&gt;% \n  metaSurvey::step_recode(\n    \"po\",\n    ESTADO == 1 ~ 1,\n    .default = 0\n  ) %&gt;% \n  metaSurvey::step_recode(\n    \"pd\",\n    ESTADO == 2 ~ 1,\n    .default = 0\n  )\n\n\nmetaSurvey::view_graph(ph2022_3)"
  },
  {
    "objectID": "chapters/chapter6.html",
    "href": "chapters/chapter6.html",
    "title": "6  Infraestructura",
    "section": "",
    "text": "Infra\nDocker\nKubernetes\nTests\nEnvío a CRAN"
  }
]